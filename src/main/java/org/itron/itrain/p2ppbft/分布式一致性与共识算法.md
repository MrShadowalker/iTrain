什么是共识呢？通常的理解就是共同的认识、一致的看法。在区块链系统中，共识指的是区块链系统中各个节点账本数据同步的实现。 共识算法并非凭空而生，而是基于分布式系统中为众人所熟知的分布式一致算法得来的。

# 区块链的分布式

区块链系统本质上是分布式网络系统，而在分布式系统中，最核心的问题就是“一致性（Consistency）的问题”，即在分布式网络的各个节点中如何保持节点数据的一致性。
如果在分布式系统中，一致性无法保证，那么分布式系统就变成了不可用的系统，因此保证一致性是分布式系统中最为重要的内容。

略微延伸到分布式领域的 CAP 理论。CAP 理论中论述了在任何一个分布式系统都无法同时满足 Consistency（一致性）、Availability（可用性）和 Partition tolerance（分区容错性）这三个基本需求。
最多只能满足其中两项，而一致性是不能丢弃的。 当然，分布式系统中的分布式的一致性问题主要还是用来保证数据的一致性。

目前，各类分布式系统中使用的分布式一致性算法比较多，但基本都是源于 Paxos 分布式一致性算法。

> There is only one consensus protocol, and that's Paxos —— all other approaches are just broken versions of Paxos.
`—— from Mike Burrows, author of Google Chubby`

# Paxos 算法

Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。 一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么他们最后能得到一个一致的状态。
为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。 一个通用的一致性算法可以应用在许多场景中，是分布式计算中的重要问题。因此从20世纪80年代起对于一致性算法的研究就没有停止过。

节点通信存在两种模型：共享内存（Shared memory）和消息传递（Messages passing）。Paxos 算法就是一种基于消息传递模型的一致性算法。 不仅仅是分布式系统中，凡是多个过程需要达成某种一致的场合都可以使用Paxos
算法。 一致性算法可以通过共享内存（需要锁）或者消息传递实现，Paxos 算法采用的是后者。

Paxos 算法适用的几种情况：

- 一台机器中多个进程/线程达成数据一致；
- 分布式文件系统或者分布式数据库中多客户端并发读写数据；
- 分布式存储中多个副本响应读写请求的一致性。

除经典的分布式一致性算法 Paxos 外，还有一些算法也隐藏于我们常用的中间件中，如 ZooKeeper，二、三阶段提交协议等。

# ZooKeeper 中的分布式一致性算法实现

ZooKeeper 是一个开源的分布式协调服务，分布式应用程序可以基于它实现诸如数据发布/发布、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。 ZooKeeper 的设计思想源于
Google 的 Chubby，目前是 Hadoop 和 Hbase 中的重要组件。

ZooKeeper 使用了 ZAB（ZooKeeper Atomic Broadcast，ZooKeeper 原子消息广播）协议作为其数据一致性的核心算法。 ZAB 协议是为 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。
基于 ZAB 协议，ZooKeeper 实现了在主/备模式下的系统架构中来保持集群中各副本之间的数据一致性。 ZooKeeper 使用一个单一的主进程来接收并处理客户端的所有事务请求，并采用 ZAB 协议将服务器数据的状态变更以事务
Proposal 的形式广播到所有的副本进程中。 ZAB 协议的主备模型架构保证了同一时刻集群中只能有一个主进程来广播服务器的状态变更，因此能够很好地处理客户端的大量并发请求。 ZAB 协议的核心是定义了能改变 ZooKeeper
服务器数据状态的事务请求的处理方式，即所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为 Leader 服务器，其他服务器则成为 Follower 服务器。 Leader 服务器负责将一个客户端事务请求转化成一个事务
Proposal（提议），并将该 Proposal 分发给集群中所有的 Follower 服务器，之后 Leader 服务器需要等待所有 Follower 服务器的反馈。 一旦超过半数的 Follower
服务器进行了正确的反馈后，Leader 就会再次向所有的 Follower 服务器分发 Commit 消息，要求其提交前一个 Proposal。

在整个服务框架启动过程中，如果 Leader 服务器出现网络中断、崩溃退出与充气等异常情况，则 ZAB 协议就会进入恢复模式，并选举产生新的 Leader 服务器。 当选举产生了新的 Leader 服务器，且集群中已经有过半的极其与该
Leader 服务器完成了状态同步之后，ZAB 协议就会退出恢复模式。 状态同步是指数据同步，用来保证集群中过半的机器能够和 Leader 服务器的数据状态保持一致。

新 Leader 的选举算法是分布式一致性算法的一种。 在 ZooKeeper 中，提供了三种选举算法，分别是 LeaderElection、AuthFastLeaderElection 和 FastLeaderElection。
默认的选举算法是 FastLeaderElection。选举过程如下： 每个在 ZooKeeper 集群中的服务器都会读取格子服务器中当前保存在磁盘的数据，ZooKeeper 系统中的每份数据，都有一个唯一的 id 值。 id
值是依次递增的，因此越新的数据，对应的 id 值就越大。 数据读取完毕之后，ZooKeeper 服务器就可以开启 Leader 选举了。通常每个 ZooKeeper 服务器发送自己选举的 Leader 信息中会包含以下几部分内容：

- 所选举 Leader 的 id。Leader 的 id 源于配置文件中配置的每个服务器的 id。在选举开始阶段，每台服务器都会选举自己为 Leader，这个值就是自己服务器的 id。
- 当前服务器中最大数据的 id。服务器中这个值越大，说明存放的数据越新。
- 逻辑时钟的值。逻辑时钟的值从 0 开始递增，每次选举对应一个。因此，在同一次选举中，逻辑时钟的值应该是一致的；若逻辑时钟的值不同，则逻辑时钟值越大，说明这次选举 Leader 的进程越新。
- 本机在当前选举过程中的状态。选举状态有 4 种类型，分别是：LOOKING、FOLLOWING、OBSERVING、LEADING。

每台服务器将自己服务器的状态数据发送到集群中的其他服务期之后，也会接收来自其他服务器的状态数据，并进行如下处理：

> 1. 如果所接收数据服务器的状态是在选举阶段，即 LOOKING 状态，那么首先判断逻辑时钟的值。

此时分为以下三种情况：

1.1 如果发送过来的逻辑时钟大于当前的逻辑时钟。

说明这是比当前保存的选举更新一次的选举，此时需要更新本机的逻辑时钟数据，同时将之前收集到的来自其他服务器的选举清空，因为这些数据已经不再有效了。

随后判断是否需要更新当前自己的选举情况。服务器根据选举 Leader id 保存的最大数据 id 来判断是否需要更新选举情况：

- 当数据 id 不同时，数据 id 大者胜出。
- 当数据 id 相同时，比较 Leader id 的值，Leader id 大者胜出。

随后再将自身最新的选举结果广播给集群中的其他服务器。

1.2 发送过来的逻辑时钟数据小于本机的逻辑时钟

这说明对方在一个相对较早的选举进程中，属于重复数据，因此服务器无需处理该部分数据，只需将本机的数据发送过去即可。

1.3 发送过来的逻辑时钟数据与本机的逻辑时钟数据相同。

此时调用 totalOrderPredicate 函数判断是否需要更新本机的数据，如果需要更新，则再将自己最新的选举结果广播给集群中的其他服务器。

以上三种情况处理完毕之后，需处理如下两种情况：

1.a 判断服务器是不是已经收集到了集群中所有服务器的选举状态。

如果是，则根据选举结果设置自己的角色（FOLLOWING 还是 LEADER），并退出选举过程。

1.b 若没有收集到所有服务器的选举状态。

则需要判断根据以上过程选举出的 Leader 是不是得到了超过半数以上服务器的支持。如果是，则尝试在 200ms 内接收数据。 如果没有新的数据到来，则说明大家都已经默认了这个结果，设置自己的角色，退出选举过程。

> 2. 如果服务器当前不处于选举状态，即在 FOLLOWING 或 LEADING 状态，此时会做以下两个判断。

2.1 如果逻辑时钟相同，则将该数据保存到 recvset。如果所接收服务器宣称自己是 Leader，那么将判断是不是有半数以上的服务器选举它。如果是，则设置选举状态，退出选举过程。

2.2 如果逻辑时钟不同，则说明在另一个选举过程中已经有了选举结果，于是将该选举结果加入到 outofelection 集合中，再根据 outofelection 来判断是否可以结束选举。
如果可以结束选举，则保存逻辑时钟，设置选举状态，退出选举过程。
